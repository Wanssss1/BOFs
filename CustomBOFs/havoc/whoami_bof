#include <windows.h>

DECLSPEC_IMPORT VOID WINAPI BeaconPrintf(int type, char* fmt, ...);

DECLSPEC_IMPORT BOOL WINAPI ADVAPI32$GetUserNameW(LPWSTR, LPDWORD);
DECLSPEC_IMPORT BOOL WINAPI ADVAPI32$OpenProcessToken(HANDLE, DWORD, PHANDLE);
DECLSPEC_IMPORT BOOL WINAPI ADVAPI32$GetTokenInformation(HANDLE, TOKEN_INFORMATION_CLASS, LPVOID, DWORD, PDWORD);
DECLSPEC_IMPORT BOOL WINAPI ADVAPI32$ConvertSidToStringSidW(PSID, LPWSTR*);
DECLSPEC_IMPORT BOOL WINAPI ADVAPI32$CheckTokenMembership(HANDLE, PSID, PBOOL);
DECLSPEC_IMPORT BOOL WINAPI ADVAPI32$AllocateAndInitializeSid(PSID_IDENTIFIER_AUTHORITY, BYTE, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, DWORD, PSID*);
DECLSPEC_IMPORT PVOID WINAPI ADVAPI32$FreeSid(PSID);

DECLSPEC_IMPORT HANDLE WINAPI KERNEL32$GetCurrentProcess();
DECLSPEC_IMPORT BOOL WINAPI KERNEL32$CloseHandle(HANDLE);
DECLSPEC_IMPORT HLOCAL WINAPI KERNEL32$LocalFree(HLOCAL);
DECLSPEC_IMPORT DWORD WINAPI KERNEL32$GetComputerNameW(LPWSTR, LPDWORD);
DECLSPEC_IMPORT DWORD WINAPI KERNEL32$GetEnvironmentVariableW(LPCWSTR, LPWSTR, DWORD);
DECLSPEC_IMPORT LPWSTR WINAPI KERNEL32$lstrcpyW(LPWSTR, LPCWSTR);
DECLSPEC_IMPORT LPWSTR WINAPI KERNEL32$lstrcatW(LPWSTR, LPCWSTR);

void go(char* args, int len) {
    WCHAR username[256] = {0};
    WCHAR domain[256] = {0};
    WCHAR computername[256] = {0};
    WCHAR fullname[512] = {0};
    DWORD size = 256;
    HANDLE hToken = NULL;
    LPWSTR sidString = NULL;
    
    // Obtener nombre de usuario
    if (!ADVAPI32$GetUserNameW(username, &size)) {
        BeaconPrintf(0, "[-] Failed to get username\n");
        return;
    }
    
    // Obtener hostname
    size = 256;
    KERNEL32$GetComputerNameW(computername, &size);
    
    // Obtener dominio
    size = 256;
    KERNEL32$GetEnvironmentVariableW(L"USERDOMAIN", domain, size);
    
    // Construir nombre completo
    KERNEL32$lstrcpyW(fullname, domain);
    KERNEL32$lstrcatW(fullname, L"\\");
    KERNEL32$lstrcatW(fullname, username);
    
    BeaconPrintf(0, "[+] User: %ls\n[+] Host: %ls\n", fullname, computername);
    
    // Abrir token
    if (!ADVAPI32$OpenProcessToken(KERNEL32$GetCurrentProcess(), TOKEN_QUERY, &hToken)) {
        BeaconPrintf(0, "[-] Cannot open token\n");
        return;
    }
    
    // Obtener SID
    BYTE buffer[512];
    DWORD returnLength = 0;
    
    if (ADVAPI32$GetTokenInformation(hToken, TokenUser, buffer, sizeof(buffer), &returnLength)) {
        TOKEN_USER* tokenUser = (TOKEN_USER*)buffer;
        
        if (ADVAPI32$ConvertSidToStringSidW(tokenUser->User.Sid, &sidString)) {
            BeaconPrintf(0, "[+] SID: %ls\n", sidString);
            KERNEL32$LocalFree(sidString);
        }
    }
    
    // Verificar admin local
    SID_IDENTIFIER_AUTHORITY NtAuthority = {SECURITY_NT_AUTHORITY};
    PSID AdminGroup = NULL;
    BOOL isAdmin = FALSE;
    
    if (ADVAPI32$AllocateAndInitializeSid(&NtAuthority, 2, 
        SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS,
        0, 0, 0, 0, 0, 0, &AdminGroup)) {
        
        if (ADVAPI32$CheckTokenMembership(NULL, AdminGroup, &isAdmin)) {
            BeaconPrintf(0, "[+] Admin: %ls\n", isAdmin ? L"Yes" : L"No");
        }
        ADVAPI32$FreeSid(AdminGroup);
    }
    
    // Verificar elevation
    TOKEN_ELEVATION elevation;
    if (ADVAPI32$GetTokenInformation(hToken, TokenElevation, &elevation, sizeof(elevation), &returnLength)) {
        BeaconPrintf(0, "[+] Elevated: %ls\n", elevation.TokenIsElevated ? L"Yes" : L"No");
    }
    
    KERNEL32$CloseHandle(hToken);
}
